<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Review Statement - Expense Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-gray-50 min-h-screen" style="font-family: 'Montserrat', 'Segoe UI', sans-serif;">
    <div class="w-full p-0 m-0" style="padding-left:18px; padding-right:18px;">
        <!-- Header -->
        <div class="logo-banner mb-8 flex justify-between items-center">
            <div class="flex items-center gap-4">
                <img src="/logo.jpg" alt="Expense Tracker" class="logo-background" />
                <div>
                    <h1 class="text-2xl font-bold text-purple-700">Review Statement</h1>
                    <p id="statementInfo" class="text-gray-600">Loading...</p>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <a href="/" class="btn-pastel">‚Üê Back to Main</a>
            </div>
        </div>

        <!-- Loading Banner -->
        <div id="loadingBanner" class="fixed top-0 left-0 w-full z-50 hidden">
            <div class="flex items-center justify-center bg-blue-500 text-white font-semibold py-2 shadow-lg animate-pulse">
                <svg class="animate-spin h-5 w-5 mr-2 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8z"></path>
                </svg>
                <span id="loadingText">Processing...</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="glass-block p-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4 items-center justify-between">
                <div class="flex gap-2">
                    <button id="recategorizeBtn" class="btn-pastel">üîÑ Recategorize All</button>
                    <button id="selectAllBtn" class="btn-pastel">‚òëÔ∏è Select All</button>
                    <button id="deselectAllBtn" class="btn-pastel">‚òê Deselect All</button>
                </div>
                <div class="flex gap-2">
                    <button id="cancelBtn" class="btn-pastel-red">‚ùå Cancel & Delete</button>
                    <button id="approveBtn" class="btn-pastel-green">‚úÖ Approve & Save</button>
                </div>
            </div>
        </div>

        <!-- Summary -->
        <div class="glass-block p-4 mb-6">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
                <div>
                    <div class="text-2xl font-bold text-purple-700" id="totalCount">0</div>
                    <div class="text-sm text-gray-600">Total Transactions</div>
                </div>
                <div>
                    <div class="text-2xl font-bold text-purple-700" id="totalAmount">$0.00</div>
                    <div class="text-sm text-gray-600">Total Amount</div>
                </div>
                <div>
                    <div class="text-2xl font-bold text-purple-700" id="selectedCount">0</div>
                    <div class="text-sm text-gray-600">Selected</div>
                </div>
                <div>
                    <div class="text-2xl font-bold text-purple-700" id="selectedAmount">$0.00</div>
                    <div class="text-sm text-gray-600">Selected Amount</div>
                </div>
            </div>
        </div>

        <!-- Expenses Table -->
        <div class="glass-block mb-8 p-4 table-container">
            <table id="expensesTable">
                <thead>
                    <tr class="text-purple-200">
                        <th class="py-2 px-3 w-10 text-center">
                            <input type="checkbox" id="selectAllCheckbox" title="Select all rows">
                        </th>
                        <th class="py-2 px-3 w-10 text-center">Del</th>
                        <th class="py-2 px-3 w-32">Date</th>
                        <th class="py-2 px-3 w-56">Description</th>
                        <th class="py-2 px-3 w-24">Amount</th>
                        <th class="py-2 px-3 w-36">Category</th>
                        <th class="py-2 px-3 w-36">Need Category</th>
                        <th class="py-2 px-3 w-28">Card</th>
                        <th class="py-2 px-3 w-28">Spender</th>
                        <th class="py-2 px-3 w-16 text-center">Split</th>
                        <th class="py-2 px-3 w-16 text-center">Outlier</th>
                        <th class="py-2 px-3 w-40">Notes</th>
                    </tr>
                </thead>
                <tbody id="expensesTableBody">
                    <!-- Staging expenses will be populated here -->
                </tbody>
            </table>
            
            <!-- Selection Summary -->
            <div id="selectionSummary" class="selection-summary mt-3 p-3 rounded" style="display: none;">
                <div class="flex justify-between items-center">
                    <span id="selectionCount" class="text-sm font-medium">0 rows selected</span>
                    <span id="selectionTotal" class="text-lg font-bold">$0.00</span>
                </div>
            </div>
        </div>

        <!-- Floating Delete Button -->
        <div id="floatingDeleteBtn" class="floating-delete-btn" style="display: none;">
            <button id="bulkDeleteBtn" class="btn-pastel-red px-4 py-2 rounded-lg shadow-lg">
                <span>üóëÔ∏è Delete Selected (<span id="selectedCountFloat">0</span>)</span>
            </button>
        </div>
    </div>

    <script type="module">
        // Import all necessary functions and utilities
        import { API_URL } from '/config.js';
        import { formatDate, renderExpenses, updateAllSpendingDisplays, calculateSpendingTotals, addOptionToSelect } from '/render.js';
        import { getCategoryMeta, createCategoryDropdown, handleCategorySelection } from '/categories.js';
        
        // Make render functions available globally for staging
        window.formatDate = formatDate;
        window.renderExpenses = renderExpenses;
        window.updateAllSpendingDisplays = updateAllSpendingDisplays;
        window.calculateSpendingTotals = calculateSpendingTotals;
        window.getCategoryMeta = getCategoryMeta;
        window.API_URL = API_URL;

        let currentStatementId = null;
        let stagingData = null;
        let allCategories = [];
        let selectedRows = new Set();

        // Get statement ID from URL
        function getStatementIdFromUrl() {
            const pathParts = window.location.pathname.split('/');
            const stagingIndex = pathParts.indexOf('staging');
            if (stagingIndex !== -1 && pathParts[stagingIndex + 1]) {
                return parseInt(pathParts[stagingIndex + 1]);
            }
            return null;
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            currentStatementId = getStatementIdFromUrl();
            
            if (!currentStatementId) {
                alert('Invalid statement ID');
                window.location.href = '/';
                return;
            }

            await loadCategories();
            await loadStagingData();
            setupEventListeners();
        });

        async function loadCategories() {
            try {
                const response = await fetch('/categories');
                const data = await response.json();
                allCategories = data.categories || [];
            } catch (error) {
                console.error('Error loading categories:', error);
                allCategories = [];
            }
        }

        async function loadStagingData() {
            try {
                showLoading('Loading statement data...');
                const response = await fetch(`/api/staging/${currentStatementId}`);
                
                if (!response.ok) {
                    throw new Error('Failed to load staging data');
                }

                stagingData = await response.json();
                updateStatementInfo();
                renderStagingTable();
                updateSummary();
            } catch (error) {
                console.error('Error loading staging data:', error);
                alert('Error loading statement data');
                window.location.href = '/';
            } finally {
                hideLoading();
            }
        }

        function updateStatementInfo() {
            const info = document.getElementById('statementInfo');
            if (stagingData) {
                const date = new Date(stagingData.upload_date).toLocaleDateString();
                info.textContent = `${stagingData.filename} - Uploaded: ${date}`;
            }
        }

        function renderStagingTable() {
            if (!stagingData || !stagingData.expenses) {
                const tbody = document.getElementById('expensesTableBody');
                tbody.innerHTML = '<tr><td colspan="12" class="text-center py-4">No expenses found</td></tr>';
                return;
            }

            // Convert staging expenses to the format expected by render.js
            const expenses = stagingData.expenses.map(expense => ({
                ...expense,
                // Ensure all fields are in the right format
                amount: parseFloat(expense.amount || 0),
                split_cost: Boolean(expense.split_cost),
                outlier: Boolean(expense.outlier)
            }));

            // Store expenses globally for render.js functions to access
            window.currentExpenses = expenses;
            window.filteredExpenses = expenses;
            window.allExpenses = expenses;

            // Use the existing renderExpenses function but without manual entry row
            renderStagingExpenses(expenses);
        }

        function renderStagingExpenses(expenses) {
            // Update total spending blocks using existing function
            updateAllSpendingDisplays(expenses);
            
            const tbody = document.getElementById('expensesTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Use the existing renderExpenseRow pattern but adapted for staging
            expenses.forEach(exp => {
                renderStagingExpenseRowWithRenderJS(tbody, exp);
            });
            
            // Setup inline editing for staging using existing patterns
            setupStagingInlineEditingWithRenderJS(tbody, expenses);
        }

        function renderStagingExpenseRowWithRenderJS(tbody, exp) {
            // Get category metadata using existing helper
            const meta = getCategoryMeta ? getCategoryMeta(exp.category) : { icon: 'üè∑Ô∏è', color: '#818cf8' };
            let needCat = exp.need_category || 'Need';
            let needBadgeClass = needCat === 'Luxury' ? 'luxury-badge' : 'need-badge';
            const splitChecked = exp.split_cost ? 'checked' : '';
            const outlierChecked = exp.outlier ? 'checked' : '';
            
            const tr = document.createElement('tr');
            tr.className = 'border-b border-gray-200 hover:bg-gray-50';
            tr.dataset.stagingId = exp.id;
            
            // Use similar HTML structure as render.js but with staging-specific attributes
            tr.innerHTML = `
                <td class="py-2 px-3 text-center">
                    <input type="checkbox" class="autofill-row-checkbox" data-staging-id="${exp.id}">
                </td>
                <td class="py-2 px-3 text-center">
                    <button class="text-red-400 hover:text-red-600 font-bold text-lg delete-row-btn" data-staging-id="${exp.id}" title="Delete">√ó</button>
                </td>
                <td class="py-2 px-3 editable-cell" data-field="date" data-staging-id="${exp.id}" data-sort-value="${exp.date || ''}">${formatDate ? formatDate(exp.date) : (exp.date || '')}</td>
                <td class="py-2 px-3 editable-cell" data-field="description" data-staging-id="${exp.id}">${exp.description || ''}</td>
                <td class="py-2 px-3 editable-cell" data-field="amount" data-staging-id="${exp.id}">$${Number(exp.amount).toFixed(2)}</td>
                <td class="py-2 px-3 editable-cell" data-field="category" data-staging-id="${exp.id}" style="text-align:center;">
                    <span style="font-size:1.2em;vertical-align:middle;margin-right:4px;color:${meta.color};">${meta.icon}</span>
                    ${(exp.category || 'shopping').charAt(0).toUpperCase()+(exp.category || 'shopping').slice(1)}
                </td>
                <td class="py-2 px-3 editable-cell" data-field="need_category" data-staging-id="${exp.id}" style="text-align:center;"><span class="${needBadgeClass}">${needCat}</span></td>
                <td class="py-2 px-3 editable-cell" data-field="card" data-staging-id="${exp.id}">${exp.card || ''}</td>
                <td class="py-2 px-3 editable-cell" data-field="who" data-staging-id="${exp.id}">${(exp.who === 'Ameya' || exp.who === 'Gautami') ? exp.who : (exp.who ? `<span class='custom-who'>${exp.who}</span>` : '')}</td>
                <td class="py-2 px-3 text-center"><input type="checkbox" class="split-checkbox" data-staging-id="${exp.id}" ${splitChecked}></td>
                <td class="py-2 px-3 text-center"><input type="checkbox" class="outlier-checkbox" data-staging-id="${exp.id}" ${outlierChecked}></td>
                <td class="py-2 px-3 editable-cell" data-field="notes" data-staging-id="${exp.id}">${exp.notes || ''}</td>
            `;
            tbody.appendChild(tr);
            
            setupStagingRowListeners(tr, exp);
        }

        function setupStagingRowListeners(tr, exp) {
            // Selection checkbox listener
            const selectionCb = tr.querySelector('.autofill-row-checkbox');
            if (selectionCb) {
                selectionCb.addEventListener('change', () => {
                    const stagingId = parseInt(selectionCb.dataset.stagingId);
                    if (selectionCb.checked) {
                        selectedRows.add(stagingId);
                    } else {
                        selectedRows.delete(stagingId);
                    }
                    updateSelection();
                });
            }
            
            // Checkbox listeners for split and outlier
            const splitCb = tr.querySelector('.split-checkbox');
            if (splitCb) {
                splitCb.addEventListener('change', async () => {
                    splitCb.dataset.field = 'split_cost';
                    await updateStagingExpense(splitCb);
                });
            }
            
            const outlierCb = tr.querySelector('.outlier-checkbox');
            if (outlierCb) {
                outlierCb.addEventListener('change', async () => {
                    outlierCb.dataset.field = 'outlier';
                    await updateStagingExpense(outlierCb);
                });
            }
            
            // Delete button
            const deleteBtn = tr.querySelector('.delete-row-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', async (e) => {
                    const stagingId = parseInt(deleteBtn.dataset.stagingId);
                    if (confirm('Delete this transaction?')) {
                        await deleteStagingExpense(stagingId);
                    }
                    e.stopPropagation();
                });
            }
        }

        function setupStagingInlineEditingWithRenderJS(tbody, expenses) {
            // Use similar inline editing logic as render.js but adapted for staging
            let editingCell = null;
            let originalContent = '';

            function exitEditMode(save = false) {
                if (!editingCell) return;
                
                if (save) {
                    const stagingId = parseInt(editingCell.getAttribute('data-staging-id'));
                    const field = editingCell.getAttribute('data-field');
                    const exp = expenses.find(e => e.id == stagingId);
                    
                    let value;
                    const input = editingCell.querySelector('input, select');
                    if (input) {
                        value = input.value;
                        if (field === 'amount') {
                            value = parseFloat(value) || 0;
                        }
                    }
                    
                    if (exp && value !== undefined) {
                        // Create a fake field element for updateStagingExpense
                        const fakeField = {
                            dataset: { stagingId: stagingId, field: field },
                            type: input ? input.type : 'text',
                            value: value
                        };
                        
                        // Try to update and only restore original content on failure
                        updateStagingExpense(fakeField, editingCell).then(success => {
                            if (success) {
                                // Success: cell display was already updated by updateStagingExpense
                                editingCell.classList.remove('editing-cell');
                                editingCell = null;
                                originalContent = '';
                            } else {
                                // Failure: restore original content
                                editingCell.innerHTML = originalContent;
                                editingCell.classList.remove('editing-cell');
                                editingCell = null;
                                originalContent = '';
                            }
                        });
                        return; // Don't continue to the restoration below
                    }
                }
                
                // Restore original content (for cancellation or when no save needed)
                editingCell.innerHTML = originalContent;
                editingCell.classList.remove('editing-cell');
                editingCell = null;
                originalContent = '';
            }

            tbody.querySelectorAll('.editable-cell').forEach(cell => {
                cell.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    
                    if (editingCell && editingCell !== cell) {
                        exitEditMode(true);
                    }
                    
                    if (editingCell === cell) return;
                    
                    editingCell = cell;
                    originalContent = cell.innerHTML;
                    cell.classList.add('editing-cell');
                    
                    const stagingId = cell.getAttribute('data-staging-id');
                    const field = cell.getAttribute('data-field');
                    const exp = expenses.find(e => e.id == stagingId);
                    
                    if (!exp) return;
                    
                    // Create appropriate input based on field type
                    let inputHtml = '';
                    if (field === 'date') {
                        inputHtml = `<input type="date" value="${exp.date || ''}" class="w-full">`;
                    } else if (field === 'amount') {
                        inputHtml = `<input type="number" step="0.01" value="${exp.amount || ''}" class="w-full">`;
                    } else if (field === 'category') {
                        // Use the existing category dropdown from categories.js
                        const categorySelect = createCategoryDropdown(exp.category);
                        categorySelect.className = 'w-full';
                        cell.innerHTML = '';
                        cell.appendChild(categorySelect);
                        categorySelect.focus();
                        
                        // Handle category selection
                        categorySelect.addEventListener('change', async () => {
                            await handleCategorySelection(categorySelect, async (selectedCategory) => {
                                const fakeField = {
                                    dataset: { stagingId: stagingId, field: field },
                                    type: 'select',
                                    value: selectedCategory
                                };
                                const success = await updateStagingExpense(fakeField, cell);
                                if (success) {
                                    // Update was successful, exit edit mode without restoring
                                    cell.classList.remove('editing-cell');
                                    editingCell = null;
                                    originalContent = '';
                                } else {
                                    // Update failed, restore original content
                                    exitEditMode(false);
                                }
                            });
                        });
                        
                        categorySelect.addEventListener('blur', () => {
                            if (categorySelect.value !== '__ADD_NEW__') {
                                exitEditMode(true);
                            }
                        });
                        
                        categorySelect.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && categorySelect.value !== '__ADD_NEW__') exitEditMode(true);
                            if (e.key === 'Escape') exitEditMode(false);
                        });
                        return; // Exit early since we handled this case differently
                    } else if (field === 'need_category') {
                        inputHtml = `<select class="w-full">
                            <option value="Need" ${exp.need_category === 'Need' ? 'selected' : ''}>Need</option>
                            <option value="Luxury" ${exp.need_category === 'Luxury' ? 'selected' : ''}>Luxury</option>
                        </select>`;
                    } else if (field === 'who') {
                        inputHtml = `<select class="w-full">
                            <option value="Ameya" ${exp.who === 'Ameya' ? 'selected' : ''}>Ameya</option>
                            <option value="Gautami" ${exp.who === 'Gautami' ? 'selected' : ''}>Gautami</option>
                        </select>`;
                    } else {
                        inputHtml = `<input type="text" value="${exp[field] || ''}" class="w-full">`;
                    }
                    
                    cell.innerHTML = inputHtml;
                    const input = cell.querySelector('input, select');
                    if (input) {
                        input.focus();
                        if (input.select) input.select();
                        
                        input.addEventListener('blur', () => exitEditMode(true));
                        input.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') exitEditMode(true);
                            if (e.key === 'Escape') exitEditMode(false);
                        });
                    }
                });
            });

            // Exit edit mode when clicking outside
            document.addEventListener('click', function(e) {
                if (editingCell && !editingCell.contains(e.target)) {
                    exitEditMode(true);
                }
            }, { capture: true });
        }

        function setupEventListeners() {
            // Global select all checkbox
            document.getElementById('selectAllCheckbox').addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('.autofill-row-checkbox');
                checkboxes.forEach(cb => {
                    cb.checked = this.checked;
                    const stagingId = parseInt(cb.dataset.stagingId);
                    if (this.checked) {
                        selectedRows.add(stagingId);
                    } else {
                        selectedRows.delete(stagingId);
                    }
                });
                updateSelection();
            });

            // Action buttons
            document.getElementById('recategorizeBtn').addEventListener('click', recategorizeAll);
            document.getElementById('selectAllBtn').addEventListener('click', selectAll);
            document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
            document.getElementById('approveBtn').addEventListener('click', approveStatement);
            document.getElementById('cancelBtn').addEventListener('click', cancelStatement);
            document.getElementById('bulkDeleteBtn').addEventListener('click', bulkDeleteSelected);
        }

        async function updateStagingExpense(field, cell = null) {
            const stagingId = parseInt(field.dataset.stagingId);
            const fieldName = field.dataset.field;
            let value = field.type === 'checkbox' ? field.checked : field.value;

            // Convert boolean to integer for database
            if (field.type === 'checkbox') {
                value = value ? 1 : 0;
            }

            try {
                const response = await fetch(`/api/staging/expense/${stagingId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        [fieldName]: value
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to update expense');
                }

                // Update local data
                const expense = stagingData.expenses.find(e => e.id === stagingId);
                if (expense) {
                    expense[fieldName] = field.type === 'checkbox' ? Boolean(value) : value;
                    
                    // Update the global expense arrays too
                    const globalExpense = window.filteredExpenses?.find(e => e.id === stagingId);
                    if (globalExpense) {
                        globalExpense[fieldName] = field.type === 'checkbox' ? Boolean(value) : value;
                    }
                    
                    // Update the cell display immediately (similar to render.js)
                    if (cell) {
                        updateCellDisplay(cell, fieldName, value);
                    }
                    
                    updateSummary();
                    // Update spending displays
                    updateAllSpendingDisplays(window.filteredExpenses || stagingData.expenses);
                }
                
                return true; // Success
            } catch (error) {
                console.error('Error updating expense:', error);
                alert('Failed to update expense');
                // Revert the field
                if (field.type === 'checkbox') {
                    field.checked = !field.checked;
                } else {
                    field.value = '';
                }
                return false; // Failure
            }
        }

        function updateCellDisplay(cell, fieldName, value) {
            if (fieldName === 'category') {
                const meta = getCategoryMeta ? getCategoryMeta(value) : { icon: 'üè∑Ô∏è', color: '#818cf8' };
                cell.innerHTML = `
                    <span style="font-size:1.2em;vertical-align:middle;margin-right:4px;color:${meta.color};">${meta.icon}</span>
                    ${(value || 'shopping').charAt(0).toUpperCase() + (value || 'shopping').slice(1)}
                `;
            } else if (fieldName === 'need_category') {
                let needBadgeClass = value === 'Luxury' ? 'luxury-badge' : 'need-badge';
                cell.innerHTML = `<span class="${needBadgeClass}">${value}</span>`;
            } else if (fieldName === 'amount') {
                cell.textContent = `$${Number(value).toFixed(2)}`;
            } else if (fieldName === 'date') {
                cell.textContent = formatDate ? formatDate(value) : value;
            } else if (fieldName === 'who') {
                cell.innerHTML = (value === 'Ameya' || value === 'Gautami') ? value : (value ? `<span class='custom-who'>${value}</span>` : '');
            } else {
                cell.textContent = value;
            }
        }

        async function deleteStagingExpense(stagingId) {
            try {
                showLoading('Deleting transaction...');
                const response = await fetch(`/api/staging/expense/${stagingId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete expense');
                }

                // Remove from local data and UI
                stagingData.expenses = stagingData.expenses.filter(e => e.id !== stagingId);
                selectedRows.delete(stagingId);
                
                const row = document.querySelector(`tr[data-staging-id="${stagingId}"]`);
                if (row) {
                    row.remove();
                }

                updateSummary();
                updateSelection();
            } catch (error) {
                console.error('Error deleting expense:', error);
                alert('Failed to delete expense');
            } finally {
                hideLoading();
            }
        }

        async function recategorizeAll() {
            if (!confirm('Recategorize all transactions? This will overwrite existing categories.')) {
                return;
            }

            try {
                showLoading('Recategorizing transactions...');
                const response = await fetch(`/api/staging/${currentStatementId}/recategorize`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to recategorize');
                }

                await loadStagingData(); // Reload to show updated categories
            } catch (error) {
                console.error('Error recategorizing:', error);
                alert('Failed to recategorize transactions');
            } finally {
                hideLoading();
            }
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('.autofill-row-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
                selectedRows.add(parseInt(cb.dataset.stagingId));
            });
            document.getElementById('selectAllCheckbox').checked = true;
            updateSelection();
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('.autofill-row-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
            });
            selectedRows.clear();
            document.getElementById('selectAllCheckbox').checked = false;
            updateSelection();
        }

        async function bulkDeleteSelected() {
            if (selectedRows.size === 0) {
                alert('No transactions selected');
                return;
            }

            if (!confirm(`Delete ${selectedRows.size} selected transactions?`)) {
                return;
            }

            try {
                showLoading('Deleting selected transactions...');
                
                for (const stagingId of selectedRows) {
                    await fetch(`/api/staging/expense/${stagingId}`, {
                        method: 'DELETE'
                    });
                }

                // Remove from local data and UI
                stagingData.expenses = stagingData.expenses.filter(e => !selectedRows.has(e.id));
                
                selectedRows.forEach(stagingId => {
                    const row = document.querySelector(`tr[data-staging-id="${stagingId}"]`);
                    if (row) {
                        row.remove();
                    }
                });

                selectedRows.clear();
                updateSummary();
                updateSelection();
            } catch (error) {
                console.error('Error deleting expenses:', error);
                alert('Failed to delete selected transactions');
            } finally {
                hideLoading();
            }
        }

        async function approveStatement() {
            if (!confirm('Approve and save all transactions to the main database?')) {
                return;
            }

            try {
                showLoading('Saving transactions...');
                const response = await fetch(`/api/staging/${currentStatementId}/approve`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to approve statement');
                }

                alert('Statement approved and saved successfully!');
                window.location.href = '/';
            } catch (error) {
                console.error('Error approving statement:', error);
                alert('Failed to approve statement');
            } finally {
                hideLoading();
            }
        }

        async function cancelStatement() {
            if (!confirm('Cancel and delete this statement? All data will be lost.')) {
                return;
            }

            try {
                showLoading('Cancelling statement...');
                const response = await fetch(`/api/staging/${currentStatementId}/cancel`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to cancel statement');
                }

                alert('Statement cancelled and deleted.');
                window.location.href = '/';
            } catch (error) {
                console.error('Error cancelling statement:', error);
                alert('Failed to cancel statement');
            } finally {
                hideLoading();
            }
        }

        function updateSummary() {
            if (!stagingData || !stagingData.expenses) return;

            const totalCount = stagingData.expenses.length;
            const totalAmount = stagingData.expenses.reduce((sum, exp) => sum + (parseFloat(exp.amount) || 0), 0);

            document.getElementById('totalCount').textContent = totalCount;
            document.getElementById('totalAmount').textContent = `$${totalAmount.toFixed(2)}`;
            
            // Use the existing spending display functions if available
            if (window.updateAllSpendingDisplays && window.filteredExpenses) {
                updateAllSpendingDisplays(window.filteredExpenses);
            }
        }

        function updateSelection() {
            const selectedCount = selectedRows.size;
            const selectedAmount = stagingData.expenses
                .filter(exp => selectedRows.has(exp.id))
                .reduce((sum, exp) => sum + (parseFloat(exp.amount) || 0), 0);

            document.getElementById('selectedCount').textContent = selectedCount;
            document.getElementById('selectedAmount').textContent = `$${selectedAmount.toFixed(2)}`;
            document.getElementById('selectedCountFloat').textContent = selectedCount;

            const floatingBtn = document.getElementById('floatingDeleteBtn');
            floatingBtn.style.display = selectedCount > 0 ? 'block' : 'none';
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingBanner').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingBanner').classList.add('hidden');
        }
    </script>
</body>
</html>